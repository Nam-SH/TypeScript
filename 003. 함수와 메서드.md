# 1. 함수 선언문

```typescript
function 함수이름(매개변수1: 타입1, 매개변수2: 타입2): 반환값 타입 {
    함수 몸통
}

// 예시 (parameter: a, b)
function add(a: number, b: number): number {
    return a + b
}

// argument(인수): 1, 2 => 함수 호출에 쓰임
let res = add(1, 2)
```

## 1. void 타입

- 값을 반환하지 않는 함수의 타입이다.

```typescript
function printMe(name: string, age: number): void {
    console.log(`name: ${name} age: ${age}`)
}
```

## 2. 함수 시그니처

- 함수의 타입을 함수 시그니처(function signature)라고 한다.
- 만일 매개변수와 반환값이 없으면 `() => void ` 로 나타낸다.
- 함수의 경우 매개변수타입과 반환 타입을 모두 작성하는 것이 좋다.(의도 파악)

```typescript
형식 (매개변수1 타입, 매개변수2 타입) => 반환값 타입


// 예시
let printMe: (string, number) => void = function(name: string, age: number): void {
  console.log(`name: ${name}, age: ${age}`)
}
```

## 3. type 키워드로 타입 별칭 만들기 (type alias)

- 매개변수의 개수나 타입, 반환 타입이 다른 함수를 선언하는 것을 방지할 수 있다.

```typescript
type 새로운 타입 = 기존 타입

// 예시
type stringNumberFunc = (string, number?) => void

let printMe: stringNumberFunc = function(name: string, age?: number): void {}
```

## 4. undefined 주의사항

- undefined는 최하위 타입이므로, INameable을 상속하는 자식 타입으로 간주한다.

```typescript
interface INameable {
  name: string
}
function getName(o: INameable) {
  return o.name
}

let n = getName(undefined)   // 에러: Cannot read property 'name' of undefined
```

- 따라서 값이 undefined 인지를 판별하는 코드를 작성해야 한다.

```typescript
interface INameable {
  name: string
}
function getName(o: INameable) {
  return o != undefined ? o.name : 'unknown name'

let n = getName(undefined)
console.log(n)   // unknown name
console.log(getName({ name: 'nam' }))   // nam
```

- 만일 인터페이스에 선택속성이 있다면 아래와 같이 작성한다.

```typescript
interface IAgeable {
  age?: number
}
function getAgee(o: IAgeable) {
  return o != undefined && o.age ? o.age : 0
}

console.log(getAgee(undefined))      // 0
console.log(getAgee({ age: 20 }))    // 20
```

## 5. 선택적 매개변수

- 인터페이스와 마찬가지로 함수도 변수 뒤에 ?를 가지는 선택적 매개변수를 가질 수 있다.

```typescript
function fn(name: string, age?: number): void {}

// 예시
function printMe(name: string, age?: number) {
  console.log(`name: ${name}, age: ${age}`)
}

printMe('nam', 20)    // name: nam, age: 20
printMe('nam')    // name: nam, age: undefined
```

# 2. 함수  표현식

## 1. 일등 함수(first-class function)

- 일등 함수 기능을 제공하면 함수형 프로그래밍 언어라고 한다.
- 일등 함수란, 함수와 변수를 구분하지 않는다는 의미이다.
- 아래의 예시에서 f는 변수인지 함수인지 구별이 불가능하다. 따라서 JS, TS 모두 함수형 프로그래밍 언어이다.

```typescript
let f = function(a, b) {return a + b}
f = function(a, b) {return a - b}
```

## 2. 표현식 (expression)

- 리터럴(literal), 연산자(operator), 변수, 함수 호출(function call) 등 복합적으로 구성된 코드 형태를 의미한다.
- `1 + 2` 은 `1`, `2` 라는 리터럴과 덧셈 연산자 `+`로 구성된 표현식이다. 이 표현식은 항상 컴파일러에 의해 계산법(evaluation)이 적용되어 어떤 값이 된다. 즉 컴파일러에 의해 3이라는 값이 된다.

## 3. 함수 표현식 (function expression)

- `let f = function(a, b) {return a - b}` 에서 `function(a, b) {return a - b}` 부분을 함수 표현식이라고 한다.

## 4. 계산법 (evaluation)

- 조급한 계산법(eager evaluation): 컴파일러가 타입을 파악하게 되면 식속하게 계산을 한다.
- 느긋한 계산법(lazy evaluation): 타입을 알지 못하는 경우 어떤 값인지 알수 없으므로 느긋한 계산법을 적용해 계산을 보류한다.

## 5. 함수 호출 연산자

- 함수 호출이란 함수 표현식의 몸통 부분을 실행한다는 뜻이다.
- 함수가 매개변수를 요구한다면 함수 호룿 연산자 ()안에 필요한 매개변수를 ㅁ여시할 수 있다.
- 컴파일러는 함수 호출문을 만나면 느긋한 계산법에서 조급한 계산법으로 변경 적용한다.

## 6. 익명함수

```typescript
let value = (function(a, b) {return a + b})(1, 2)
```

- 함수 호출 연산자는 연산자의 우선순위가 매우 높으므로 함수 표현식 부분을 소괄호로 묶어서 컴파일러가 정상적으로 함수 표현식의 시작과 끝 부분을 알수있게 해야 한다.

## 7. const 키워드와 함수 표현식

- 함수 표현식은 값이 변할 가능성이 있는 `let`에 선언하는 것보다는, 값이 절대로 바뀌지 않는 `const`에 하는 것이 적합하다.