# **:pencil:**1. 함수 선언문

```typescript
function 함수이름(매개변수1: 타입1, 매개변수2: 타입2): 반환값 타입 {
    함수 몸통
}

// 예시 (parameter: a, b)
function add(a: number, b: number): number {
    return a + b
}

// argument(인수): 1, 2 => 함수 호출에 쓰임
let res = add(1, 2)
```

## **:speech_balloon:**1-1. void 타입

- 값을 반환하지 않는 함수의 타입이다.

```typescript
function printMe(name: string, age: number): void {
    console.log(`name: ${name} age: ${age}`)
}
```

## **:speech_balloon:**1-2. 함수 시그니처

- 함수의 타입을 함수 시그니처(function signature)라고 한다.
- 만일 매개변수와 반환값이 없으면 `() => void ` 로 나타낸다.
- 함수의 경우 매개변수타입과 반환 타입을 모두 작성하는 것이 좋다.(의도 파악)

```typescript
형식: (매개변수1 타입, 매개변수2 타입) => 반환값 타입


// 예시
let printMe: (string, number) => void = function(name: string, age: number): void {
  console.log(`name: ${name}, age: ${age}`)
}
```

## **:speech_balloon:**1-3. type 키워드로 타입 별칭 만들기 (type alias)

- 매개변수의 개수나 타입, 반환 타입이 다른 함수를 선언하는 것을 방지할 수 있다.

```typescript
type 새로운 타입 = 기존 타입

// 예시
type stringNumberFunc = (string, number?) => void

let printMe: stringNumberFunc = function(name: string, age?: number): void {}
```

## **:speech_balloon:**1-4. undefined 주의사항

- undefined는 최하위 타입이므로, INameable을 상속하는 자식 타입으로 간주한다.

```typescript
interface INameable {
  name: string
}
function getName(o: INameable) {
  return o.name
}

let n = getName(undefined)   // 에러: Cannot read property 'name' of undefined
```

- 따라서 값이 undefined 인지를 판별하는 코드를 작성해야 한다.

```typescript
interface INameable {
  name: string
}
function getName(o: INameable) {
  return o != undefined ? o.name : 'unknown name'

let n = getName(undefined)
console.log(n)   // unknown name
console.log(getName({ name: 'nam' }))   // nam
```

- 만일 인터페이스에 선택속성이 있다면 아래와 같이 작성한다.

```typescript
interface IAgeable {
  age?: number
}
function getAgee(o: IAgeable) {
  return o != undefined && o.age ? o.age : 0
}

console.log(getAgee(undefined))      // 0
console.log(getAgee({ age: 20 }))    // 20
```

## **:speech_balloon:**1-5. 선택적 매개변수

- 인터페이스와 마찬가지로 함수도 변수 뒤에 ?를 가지는 선택적 매개변수를 가질 수 있다.

```typescript
function fn(name: string, age?: number): void {}

// 예시
function printMe(name: string, age?: number) {
  console.log(`name: ${name}, age: ${age}`)
}

printMe('nam', 20)    // name: nam, age: 20
printMe('nam')    // name: nam, age: undefined
```

# **:pencil:**2. 함수  표현식

## **:speech_balloon:**2-1. 일등 함수(first-class function)

- 일등 함수 기능을 제공하면 함수형 프로그래밍 언어라고 한다.
- 일등 함수란, 함수와 변수를 구분하지 않는다는 의미이다.
- 아래의 예시에서 f는 변수인지 함수인지 구별이 불가능하다. 따라서 JS, TS 모두 함수형 프로그래밍 언어이다.

```typescript
let f = function(a, b) {return a + b}
f = function(a, b) {return a - b}
```

## **:speech_balloon:**2-2. 표현식 (expression)

- 리터럴(literal), 연산자(operator), 변수, 함수 호출(function call) 등 복합적으로 구성된 코드 형태를 의미한다.
- `1 + 2` 은 `1`, `2` 라는 리터럴과 덧셈 연산자 `+`로 구성된 표현식이다. 이 표현식은 항상 컴파일러에 의해 계산법(evaluation)이 적용되어 어떤 값이 된다. 즉 컴파일러에 의해 3이라는 값이 된다.

## **:speech_balloon:**2-3. 함수 표현식 (function expression)

- `let f = function(a, b) {return a - b}` 에서 `function(a, b) {return a - b}` 부분을 함수 표현식이라고 한다.

## **:speech_balloon:**2-4. 계산법 (evaluation)

- 조급한 계산법(eager evaluation): 컴파일러가 타입을 파악하게 되면 식속하게 계산을 한다.
- 느긋한 계산법(lazy evaluation): 타입을 알지 못하는 경우 어떤 값인지 알수 없으므로 느긋한 계산법을 적용해 계산을 보류한다.

## **:speech_balloon:**2-5. 함수 호출 연산자

- 함수 호출이란 함수 표현식의 몸통 부분을 실행한다는 뜻이다.
- 함수가 매개변수를 요구한다면 함수 호출 연산자 ()안에 필요한 매개변수를 명시할 수 있다.
- 컴파일러는 함수 호출문을 만나면 느긋한 계산법에서 조급한 계산법으로 변경 적용한다.

## **:speech_balloon:**2-6. 익명함수

```typescript
let value = (function(a, b) {return a + b})(1, 2)
```

- 함수 호출 연산자는 연산자의 우선순위가 매우 높으므로 함수 표현식 부분을 소괄호로 묶어서 컴파일러가 정상적으로 함수 표현식의 시작과 끝 부분을 알수있게 해야 한다.

## **:speech_balloon:**2-7. const 키워드와 함수 표현식

- 함수 표현식은 값이 변할 가능성이 있는 `let`에 선언하는 것보다는, 값이 절대로 바뀌지 않는 `const`에 하는 것이 적합하다.

# **:pencil:**3. 화살표 함수와 표현식 문

## **:speech_balloon:**3-1. 화살표함수

```typescript
// 기본 함수모양
const printMe = function(name: string, age?: number): void {}


const printMe = (name: string, age?: number): void => {return a + b}  // 실행문 방식

const printMe = (name: string, age?: number): void => a + b    // 표현식 문 방식
```

## **:speech_balloon:**3-2. 실행문과 표현식 문

- JS와 TS는 실행문 지향 언어(execution-oriented language)와 표현식 지향 언어(expression-oriented language) 둘다를 지원한다. (C: 실행문 지향언어, 스칼라: 표현식 지향언어)
- 실행문은 CPU에서만 실행이 되고 결과를 반환하지 않는다. 결과를 알고 싶다면 return을 사용해야 한다.
- 반면 표현식 문(expression statement)은 CPU에서 실행된 결과를 굳이 return 키워드를 사용하지 않아도 알려준다.

```typescript
// 변수 x에 1을 설정하는 것으로 충분하다.
let x
x = 1

// 만일 아래에서 x > 10 이 true or false를 return 하지 않으면 조건문이 실행이 안된다.
// 따라서 x > 10 이 return 키워드 없이 결괏값을 반환하게 하는 것을 표현식 문 이라고 한다.
let x = 10
if (x > 10)
    x = 1
```

## **:speech_balloon:**3-3. 복합 실행문

- 2개 이상의 복합 실행문은 중괄호{}를 사용한다.
- 컴파일러는 모든 if문을 한 줄의 실행문으로 인식한다.

```typescript
if (조건문)
    싦행문
    
    
if (조건문) {
    실행문1
    실행문2
    실행문3...
}
```

## **:speech_balloon:**3-4. 함수 몸통과 복합 실행문

- function 키워드로 만다는 함수는 반드시 몸통을 중괄호{}로 감싸야 한다. (복합 실행문)

```typescript
function f() {
    let x = 1, y = 2
    let result = x + y + 10
}
```

## **:speech_balloon:**3-5. return 키워드

- return 키워드는 반드시 함수 몸통에 사용해야 한다.

```typescript
function isGreater(a: number, b: number): boolean {
    a > b    // 결과를 반환하지 않는다.
}
```

```typescript
function isGreater(a: number, b: number): boolean {
    return a > b    // 결과를 반환한다.
}
```

## **:speech_balloon:**3-6. 표현식 문 스타일의 화살표 함수 구현

- return 키워드는 복합 실맹문 안에서만 사용할 수 있다.

```typescript
// 기본적인 실행문
const isMe = (a: number, b: number): void => {
  a > b
}

// return을 가지는 실행문
const isMe2 = (a: number, b: number): boolean => {
  return a > b
}

// 표현식 문
const isMe3 = (a: number, b: number): boolean => a > b

// 에러가 나는 표현식
const isMe4 = (a: number, b: number): boolean => return a > b


console.log(isMe(3, 2))

console.log(isMe2(3, 2))

console.log(isMe3(3, 2))
```

## **:speech_balloon:**3-7. 실행문을 만드는 세미콜론

- EXNext에서 자바스크립트와 타입스크립트는 세미콜론을 생략할 수 있다.
- 타입스크립트에서는 관습적으로 표현식 문에는 세미콜론을 붙이지 않는다.

# **:pencil:**4. 일등함수 

## **:speech_balloon:**4-1. 콜백 함수

- 일등 함수: 함수 표현식을 매개변수로 받을 수 있다는 것을 의미한다.
- 매개변수 형태로 동작하는 함수를 콜백함수(callback function)이라고 한다.

```typescript
// callback이라는 매개변수가 함수 몸통에서 함수로서 호출된다.

export const init = (callback: () => void): void => callback()


// 예시
export const init = (callback: () => void): void => {
  console.log('default initialization finished.')
  callback()
  console.log('all initialization finished.')
}

init(() => console.log('custom initialization finished.'))
// 결과:
// default initialization finished.
// custom initialization finished.
// all initialization finished.
```

## **:speech_balloon:**4-2. 중첩 함수(nested function)

- 함수는 변수에 담긴 함수 표현식이므로 함수 안에 또다른 함수를 중첩해서 구현할 수 있다.

```typescript
const calc = (value: number, cb: (number) => void): void => {
  let add = (a, b) => a + b
  function multiply(a, b) {
    return a * b
  }

  let result = multiply(add(1, 2), value)
  cb(result)
}

calc(30, (result: number) => console.log(`result is ${result}`)) // result is 90
```

## **:speech_balloon:**4-3. 고차 함수와 클로저, 그리고 부분함수

- 고차함수(high-order function): 또 다른 함수를 반환하는 함수
- 2차 고차함수인 add 에 함수호출인자를 1개만 붙이면 부분 애플리케이션(partial application) 또는 부분 적용 함수(partially applied function)라 한다.

```typescript
const add = (a: number, b: number): number => a + b    // 보통함수

const add = (a: number): ((number) => number) => (b: number): number => a + b    // 고차함수
const res = add2(1)(2)

console.log(res)   // 3
```

```typescript
// 코드를 풀어서 보기

type NumberToNumberFunc = (number) => number

// 원본
const add = (a: number): NumberToNumberFunc => {
  const _add: NumberToNumberFunc = (b: number): number => {
    return a + b    // 클로저(closer)
  }
  return _add
}

// 1단계
export const add = (a: number): NumberToNumberFunc => {
  const _add = (b: number): NumberToNumberFunc => a + b
  return _add
}

// 2단계
export const add3 = (a: number): NumberToNumberFunc => (b: number): NumberToNumberFunc => a + b
```

- 3차 고차함수

```typescript
const multiply = a => b => c => a * b * c

// multiply(1) or multiply(1)(2): 부분 적용 함수
```

# **:pencil:**5. 함수 구현 기법

## **:speech_balloon:**5-1. 매개변수 기본값 지정하기

- 함수 호출 시 인수를 전달하지 않아도 매개변수에 기본값을 지정할 수 있다. 이를 디폴트 매개변수라 한다. (default parameter)

```typescript
(매개변수: 타입 = 매개변수 기본값)

// 예시
type Person = { name: string; age: number }

const makePerson = (name: string, age: number = 10): Person => {
  const person = { name: name, age: age }
  return person
}

console.log(makePerson('nam'))   // { name: 'nam', age: 10 }
console.log(makePerson('nam', 33))   // {name: 'nam', age: 33 }
```

## **:speech_balloon:**5-2. 객체 생성 시 값 부분을 생략할 수 있는 타입스크립트 구문

- 매개변수의 이름과 똑같은 이름의 소성을 가진 객체를 만들때, 속성값 부분(왼쪽 부분)을 생략할 수 있는 단축 구문(shorthand)가 존재한다.

```typescript
export type Person = { name: string; age: number }

export const makePerson = (name: string, age: number = 10): Person => {
  const person = { name, age }
  return person
}

console.log(makePerson('nam'))   // { name: 'nam', age: 10 }
console.log(makePerson('nam', 33))   // {name: 'nam', age: 33 }
```

## **:speech_balloon:**5-3. 객체를 반환하는 화살표 함수 만들기

- 컴파일러구 {}를 복합 실행문이 아닌 객체로 해석하게 하려면, 소괄호로 감싸주어야 한다.

```typescript
type Person = { name: string; age: number }

const makePerson = (name: string, age: number = 10): Person => ({ name, age })


console.log(makePerson('Jack')) // { name: 'Jack', age: 10 }
console.log(makePerson('Jane', 33)) // {name: 'Jane', age: 33 }
```

## **:speech_balloon:**5-4. 색인 키와 값으로 객체 만들기

- {[key]: value} 형태의 타입을 `색인 가능 타입(indexable type)` 이라고 하며, key, value 타입을 명시해야 한다.

```typescript
const makeObject = (key, value) = ({[key]: value})

// 사용 예시
const makeObject = (key, value) => ({ [key]: value })

// 예시
type KeyValueType = {
  [key: string]: string
}
const makeObject = (key: string, value: string): KeyValueType => ({ [key]: value })

console.log(makeObject('name', 'nam'))   //  { name: 'nam' }
console.log(makeObject('firstName', 'sh'))   //  { firstName: 'sh' }
```

# **:pencil:**6. 클래스 메서드

## **:speech_balloon:**6-1. function 함수와 this 키워드

- functin 키워드로 만든 함수는 Funtion 이란 클래스의 인스턴스, 즉 함수의 객체이다.
- 화살표 함수에는 this 키워드를 사용할 수 없다.

## **:speech_balloon:**6-2. 메서드란?

- 메서드(method): function으로 만든 함수 표현식을 담고 있는 속성
- class A는 value와 func라는 두 개의 속성을 가진다.

```typescript
export class A {
  value: number = 1
  func: () => void = function(): void {
    console.log(`value: ${this.value}`)
  }
}
```

## **:speech_balloon:**6-3. 클래스 메서드 구문

- 클래스 속성 중 함수 표현식을 담는 속성은 function 키워드를 생략하는 단축 구문(shorthand)을 제공한다.

```typescript
export class B {
  constructor(public value: number = 2) {}
  method(): void {
    console.log(`value: ${this.value}`)
  }
}

let b: B = new B()
b.method()
```

## **:speech_balloon:**6-4. 정적 메서드

- static 수정자(modifier)를 속성앞에 붙이면 정적으로 만들 수 있다.

```typescript
export class C {
  static whoAmI(): string {
    return `I'm nam`
  }

  static whoAreYou(): string {
    return `I'm namsh`
  }
}

console.log(C.whoAmI()) // I'm nam
console.log(C.whoAreYou()) // I'm namsh
```

## **:speech_balloon:**6-5. 메서드 체인

- jQuery 는 객체의 메서드를 이어서 계속 호출하게 코드를 작성할 수 있다. 이를 메서드 체인이라 한다.

```javascript
$("#p1").css("color", "red").sliceUp(2000).sliceDown(2000);
```

- 타입스크립트로 메서드 체인을 구현하려면 메서드가 항상 this를 반환하게 해야 한다.

```typescript
class Calculator {
  constructor(public value: number = 0) {}

  add(value: number) {
    this.value += value
    return this
  }
  multiply(value: number) {
    this.value *= value
    return this
  }
}

let calc = new Calculator()
let res = calc
  .add(1)
  .add(2)
  .add(2)
  .multiply(2)
  .multiply(10).value

console.log(res)    // 100
```

