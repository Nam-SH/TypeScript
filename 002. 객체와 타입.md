# 1. 타입스크립트 변수 선언문

## 1-1. 타입스크립트 기본 타입

|    유형     | 자바스크립트 타입 | 타입스크립트 타입 |
| :---------: | :---------------: | :---------------: |
|   수 타입   |      Number       |      number       |
| 불리언 타입 |      Boolean      |      boolean      |
| 문자열 타입 |      String       |      string       |
|  객체 타입  |      Object       |      object       |

## 1-2. let, const

- let 
  - let 변수이름 [= 초깃값]
  - 코드의 값이 수시로 변경될 수 있음을 암시한다.
- const
  - const 변수이름 = 초깃값
  - const로 변수를 선언할 경우에는 초깃값을 반드시 명시해야 한다.
  - 변숫값이 절대 변하지 않음을 암시한다.

## 1-3. 타입 주석

```typescript
let num: number = 1
  
let bool: boolean = true
  
let str: string = 'namsh'
  
let obj: object = { name: 'nam', age: '15' }
```

- JS와 다르게 let으로 선언한 변숫값은 타입 주석에  해당하는 타입으로만 값을 변경할 수 있다.

## 1-4. 타입 추론

- 자바스크립트와의 호환을 위해 타입 주석 부분을 생략할 수 있다.
- 명시하지 않아도 초깃값에 의해 해당하는 타입으로 지정되고, 이후 해당하는 타입의 값으로만 저장할 수 있다.

## 1-5. any 타입

- any로 지정을 하면 타입과 무관하게 어떤 종류의 값도 저장할 수 있다.

```typescript
let test: any = 0

test = 'hi'

test = true

test = {}	
```

## 1-6. undefined 타입

- 변수를 초기화 하지 않으면 해당 변수는 undefined 값을 가진다. (속성과 값이 똑같음)
- 즉, 초기화 없이 number, string 등 다른 타입으로 지정할 수 없다.

```typescript
let test: undefined = undefined

// error!
test = 'hi'  
```

# 2. 객체와 인터페이스

## 2-1. 인터페이스 선언

- object는 number, boolean, string 타입의 값을 가질 수 없지만, 이 들을 자유롭게 담을 수 있다.
- 인터페이스를 만들게 되면, object가 가지는 객체를 고정시킬 수 있다.

```typescript
interface 인터페이스 이름 {
	속성 이름[?]: 속성 타입[...]
}
```

```typescript
// example

interface test {
    name: string
    age: number
    married: boolean
}

// test는 name, age, married 외에 변수가 선언되거나, 누락될 경우 에러를 일으킨다.
```

## 2-2. 선택 속성 구문

- 특정 속성을 필수가 아닌 옵션으로 선택가능하게 한다.
- 속성 이름 뒤에 물음표 기호를 붙여서 만든다.

```typescript
// example

interface test {
    name: string		// 필수 속성
    age: number			// 필수 속성
    married?: boolean	 // 선택 속성
}

// test는 name, age는 반듯이 선언되야 되고, married는 선택사항이다.
```

## 2-3. 익명 인터페이스 (anonymous interface)

- 인터페이스와 같은 구성으로, 주로 함수를 만들때 사용된다.

```typescript
// example

let test = {
    name: string
    age: number
    married?: boolean
} = { name: 'nam', age: '20' }

function whoAmI(me: { name: string, age: number, married?: boolean }) {
    console.log(
    	me.married ? 
		`이름은 ${me.name}... 나이는 ${me.age}... 결혼: ${me.married}` :
		`이름은 ${me.name}... 나이는 ${me.age}...`
	)
}

whoAmI(test) // 이름은 nam... 나이는 20...
```



# 3. 객체와 클래스

## 3-1. 클래스 선언문

```typescript
// 클래스 기본 형태

class 클래스 이름 {
    [private | protected | public] 속성이름[?] : 속성 타입[...]
}
```

```typescript
class Test {
  name: string
  age?: number
}

let nam: Test = new Test()
nam.name = 'namsh'
nam.age = 20

console.log(nam) 	// Test { name: 'namsh', age: 20 }


// 아래처럼 선언하면 에러가 발생한다.
// let nam1: Test = new Test('namsh', 20)
```

## 3-2. 접근 제한자 (access modifier)

- public, private, protect와 같은 겁근 제한자를 이륾 앞에 붙일 수 있다.
- 생략하면 모두 public으로 간주한다.

## 3-3. 생성자 (constructor)

- 생성자의 매개변수에 public과 같은 접근 제한자를 붙이면 해당 매개변수의 이르믕ㄹ 가ㅏ진 속성이 클래스에 선언된 것처럼 동작한다.

```typescript
class Test1 {
  constructor(public name: string, public age?: number) {}
}

// 아래와 같이 선언을 해야 한다.
let nam1: Test1 = new Test1('namsh', 20)

console.log(nam1)
```

## 3-4. 인터페이스 구현

- 인터페이스는 속성에 대한 규약(spec)일 뿐, 물리적으로 속성을 만들지 않는다.
- 따라서 클래스에 반드시 인터페이스가 정의하는 속성을 멤버 속성으로 포함해야 한다.

```typescript
interface ITest {
  name: string
  age: number
}

class Test implements ITest {
  constructor(public name: string, public age: number) {}
}


let nam: ITest = new Test('namsh', 20)
console.log(nam)	// Test { name: 'namsh', age: 20 }
```

## 3-5. 추상 클래스

- class 키워드 앞에 abstract 키워드를 붙여서 만든다.
- 추상 클래스는 자신의 속성이나 메서드 앞에 abstract를 붙여 나를 상속하려는 다른 클래스에서 이 속성이나 메서드를 구현하게 한다.

```typescript
abstract class AbstractClass {
	abstract 속성이름: 속성타입
    abstract 메서드이름() {}
}

// exampe
abstract class AbstractTest {
	abstract name: string
    constructor(public age?: number) {}
}
```

## 3-6. 클래스의 상속

- extends 키워드를 이용해 상속 클래스를 만든다.
- class Test로 만들어진 nam 객체는 AbstractTest 속성이 아닌 Test의 속성 선언을 따른다.
  - AbstractTestddl `age: number` 라고 선언하고, Test가 `age?: number` 을 선언하면, age는 선택옵션이다.

```typescript
class 상속클래스 extends 부모클래스 {...}
```

```typescript
class Test extends AbstractTest {
    constructor(public name: string, age?: number) {
        super(age)
    }
}

let nam: Test = new Test('namsh', 20)	// Test { age: 20, name: 'namsh' }
```

## 3-7. static 속성

```typescript
class 클래스이름 {
    static 정적 속성 이름: 속성 타입
}
```

- "`클래스.정적 속성 이름`" 형태의 점 표기법(dot notation)을 사용해 값을 얻거나 설정한다.

```typescript
class Test {
    static initValue = 1
}

let initVal = Test.initValue	// initVal = 1
```



# 4. 객체의 비구조화 할당문

## 4-1. 구조화 (structuring)

- (구조화를 하지 않은 경우) name과 age가 사용되지만 각각 다른 의미가 되므로 구분해야 한다. (번거로움)

```typescript
let personName = 'nam'
let personAge = 20

let companyName = 'Samsung'
let companyAge = 100
```

- 따라서 인터페이스나 클래스를 사용해 관련된 정보를 묶어 새로운 타입으로 표현한다. 이를 구조화라고 한다.

```typescript
export interface IPerson {
    name: string
    age: number
}

export interface ICompony {
    name: string
    age: number
}
```

```typescript
import {IPerson, ICompony} from '경로'


let nam: IPerson = { name: 'Nam', age: 20 }
let namsh: IPerson = { name: 'Namsh', age: 20 }

let lg: IPerson = { name: 'lg', age: 60 }
let doosan: IPerson = { name: 'doosan', age: 80 }
```

## 4-2. 비구조화 (destructuring)

- 구조화된 데이터를 분해하는 것이다.
- 데이터 중 필요한 것만 사용해야할 경우에 사용한다.

```typescript
let nam: IPerson = { name: 'Nam', age: 20 }


let name: nam.name
let age: nam.age
```

- 얻고 싶은 속성을 중괄호{}에 묶으면, 객체의 생성과 함께 초깃값을 할당받는다.

```typescript
let { name, age } = nam
```

## 4-3. 잔여 연산자 (rest operator)

- 사용되는 위치에 따라 잔여 연산자(rest operator) 또는 전개 연산자(spread operator)라고 불린다.

```typescript
let address: any = {
    country: 'Korea',
    city: 'Daejeon',
    address1: 'dong-gu',
    address2: 'Panam-dong 489-33',
    address3: '666 street, 30 Floor luxury nam building',
}

const { country, city, ...detail  } = address

console.log(country)	// Korea
console.log(city)		// Daejeon
console.log(detail) 	// { address1: 'dong-gu',
                        //    address2: 'Panam-dong 489-33',
                        //    address3: '666 street, 30 Floor luxury nam building' }
```

## 4-4. 전개 연산자 (spread operator)

- 비구조화 할당이 아닌 곳에서 점 3개 연산자가 사용될 경우, 이를 전개 연산자라고 한다.
- 객체의 속성을 모두 전개해 새로운 객체로 만들어준다.

```typescript
let part1 = { name: 'nam' }
let part1 = { age: 20 }
let part1 = { city: 'Daejeon', country: 'Kr' }

let merged = { ...part1, ...part2, ...part3 }

console.log(merged)		// { name: 'nam', age: 20, city: 'Daejeon', country: 'Kr' }
```



# 5. 객체의 타입 변환

## 1. 타입단언 (type assertion) ( == 타입 변환 (type conversion))

```typescript
(<타입>객체)

or

(객체 as 타입)
```

- 아래의 object 타입은 name 속성을 가지지 않으므로, dot notation을 사용하면 에러가 난다.

```typescript
let person: object = { name: 'namsh', age: 20 }

person.name		// 에러발생

let name = (<{ name: string }>person).name		// 이런식으로 값을 가져와야 한다.
```

```typescript
interface INameable {
  name: string
}

let obj: object = { name: 'namsh' }

let name1 = (<INameable>obj).name
let name2 = (obj as INameable).name

console.log(name1, name2) 	// namsh namsh
```







